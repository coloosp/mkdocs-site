# 设计链表
[设计链表](https://leetcode.cn/problems/design-linked-list/)
设计链表应该是数据结构的入门级题目，看起来很基础但实际上并不简单，我们很容易漏掉一些遍历顺序，对于边界值的处理错误等
展示的是双向链表的写法
## 代码
```
class MyLinkedList {
public:
    struct ListNode{
        int val;
        ListNode *next;
        ListNode *prev;
        ListNode(int v):val(v),next(nullptr),prev(nullptr){}
    };


    MyLinkedList() {
        DummyHead =new ListNode(0);
        DummyHead->next=DummyHead;
        DummyHead->prev=DummyHead;
        size=0;
    }
    
    int get(int index) {
        if(index >(size-1) || index < 0){
            return -1;
        }
        ListNode *cur =DummyHead;
        int mid=size/2;
        if(index <mid){
            for(int i=0;i<index+1;i++){
                cur=cur->next;
            }
        }
        else{
            for(int i=0;i<size-index;i++){
                cur=cur->prev;
            }
            }
        int num=cur->val;
        return num;
    }
    
    void addAtHead(int val) {
        ListNode* newNode=new ListNode(val);
        ListNode* next=DummyHead->next;
        newNode->prev =DummyHead;
        newNode->next=next;
        DummyHead->next=newNode;
        next->prev=newNode;
        size++;
    }
    
    void addAtTail(int val) {
        ListNode* newNode=new ListNode(val);
        ListNode* prev=DummyHead->prev;
        newNode->next=DummyHead;
        newNode->prev=prev;
        prev->next=newNode;
        DummyHead->prev=newNode;
        size++;
    }
    
    void addAtIndex(int index, int val) {
        if(index >size){
            return;
        }
        if(index <=0){
            addAtHead(val);
            return ;
        }
        ListNode *curNode=DummyHead;
        int mid =size/2;
        if(index <mid){
            for(int i=0;i<index;i++){
                curNode=curNode->next;
            }
            ListNode* tmp=curNode->next;
            ListNode* newNode=new ListNode(val);
            newNode->next=tmp;
            newNode->prev=curNode;
            curNode->next=newNode;
            tmp->prev=newNode;
            size++;
        }
        else{
            for(int i=0;i<size-index;i++){
                curNode=curNode->prev;
            }
            ListNode *tmp=curNode->prev;
            ListNode* newNode=new ListNode(val);
            newNode->prev=tmp;
            newNode->next=curNode;
            curNode->prev=newNode;
            tmp->next=newNode;
            size++;
        }
    }
    
    void deleteAtIndex(int index) {
        if(index >(size-1) ||index <0){
            return;
        }
        ListNode* curNode=DummyHead;
        int mid=size/2;
        if(index <mid){
            for(int i=0;i<index;i++){
                curNode=curNode->next;
            }
            ListNode* tmp=curNode->next;
            ListNode *next=curNode->next->next;
            curNode->next=next;
            next->prev=curNode;
            delete tmp;  
        }
        else{
            for(int i=0;i<size- index -1;i++){
                curNode=curNode->prev;
            }
            ListNode* prev=curNode->prev->prev;
            ListNode* tmp=curNode->prev;
            curNode->prev=prev;
            prev->next=curNode;
            delete tmp;
        }
        size--;
    }
private:
    ListNode* DummyHead;
    int size;
};
```
## 解析
![alt text](image-2.png)
双向链表就是双向的链表（废话），实际上链表节点拥有前驱和后继指针可以做到很多单向链表做不到的事情，比如在查找时可以通过二分查找来快速获取index，但从后向前查找也需要注意边界值的处理，比如插入到index前，那么curNode在DummyHead从前往后就需要移动index次，可以移动到index节点前一位（即index-1）；反过来，需要从后往前移动（size-index）次，才能移动到index位置。对于删除节点我们的操作，移动的节点又会不一样。我的建议是，在本子上画一个双向链表，举例出来一个特定的index。