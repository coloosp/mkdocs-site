# 环形链表
[环形链表](https://leetcode.cn/problems/linked-list-cycle-ii/)
实际上这道题也可以使用存储表来完成，当然进阶方法肯定是不允许额外的空间开销，不过简单也意味着有效和容易想到，先试着往往哈希表什么的尝试吧。
另外这道题的双指针法还是挺缺德的（不是），初见应该是不会弄清楚
## set表
```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set <ListNode*> set;
        ListNode* cur=head;
        while(cur!=NULL){
            if(set.find(cur)!= set.end()){
                return cur;
            }
            set.insert(cur);
            cur=cur->next;
        }
        return NULL;



    }
};
```
## 双指针
```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast !=NULL && fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
            if(slow == fast){
                slow=head;
                while(slow !=fast){
                    slow=slow->next;
                    fast=fast->next;
                } 
                return slow;
            }
        }


        return NULL;

    }
};
```
## 解析
set表法我们应该很熟悉了。对于双指针法，实际上是这样的
![alt text](image-1.png)
（借用一下卡哥的图解）
当fast和slow第一次相遇时，slow走了x+y，fast走了多少呢？答案是它会在环里面绕圈子，应该是x+y+n(y+z)(n不可能为0，因为fast比slow走得快，为1的时候是绕了一圈)。那么实际上fast=2slow。也就是2（x+y）=x+y+n(y+z)，化简得到x=（n-1）y+n*z。所以我们后面会把slow再放在head位置，重新走一遍的话，就一定会在环尾也就是x处相遇。