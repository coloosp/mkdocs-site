# 链表相交
[链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)
set表存储，双指针
这里正常人都会先想到使用表来存储，估计我要是不看题解也会这样写，只要没有特殊要求，这样起码是没错且有效的
## 代码（set表）
```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set <ListNode*> set;
        while(headA!= NULL){
            set.insert(headA);
            headA=headA->next;
        }
        while(headB!=NULL){
            if(set.find(headB)!= set.end()){
                return headB;
            }
            headB=headB->next;
        }
        return NULL;



    }
};
```
## 双指针
```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA=0;
        int lenB=0;
        ListNode* curA=headA;
        ListNode* curB=headB;
        while(curA!=NULL){
            lenA++;
            curA=curA->next;
        }

        while(curB!=NULL){
            lenB++;
            curB=curB->next;
        }
        curA=headA;
        curB=headB;
        int gap=abs(lenA-lenB);
        if(lenA>lenB){
            while(gap--){
                curA=curA->next;
            }
        }
        else{
            while(gap--){
                curB=curB->next;
            }
        }

        while(curA!=NULL && curB!=NULL){
            if(curA ==curB){
                return curA;
            }
            curA=curA->next;
            curB=curB->next;
        }
        return NULL;



    }
};
```
## 解析
set表的思路应该好理解，存储A链表的节点，然后依次检索B链表的节点，返回符合的值即可
双指针的方法有点像快慢指针，假如A长度大于B，那我让curA先走差值的长度不就可以让长度相同了吗，并且你可以看出来，curA走到差值位置时，这之前一定不会存在相交（至少图片介绍是这样干的）。