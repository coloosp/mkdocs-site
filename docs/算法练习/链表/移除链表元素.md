# 移除链表元素
[删除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)
就像我们所说的，在数据结构中的移除，往往不代表弹出或者删除，在链表中，我们一般使用“跨过”来让目标元素不在链表之中
## 代码
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead=new ListNode(0);
        dummyHead->next=head;
        ListNode* cur=dummyHead;
        while(cur->next !=nullptr){
            if(cur->next->val==val){
                ListNode* tmp=cur->next;
                cur->next=cur->next->next;
                delete tmp;
            }
            else{
                cur=cur->next;
            }
           
        }
        return dummyHead->next;
    }
};
```
## 解析
为什么要使用虚拟头结点？答案是如果我们从head开始遍历，那么head也可能是目标元素，我们当然可以把head删除命令head->next作为新的head，那么假如这个新的head又是目标元素呢？这样就会显得很麻烦。对于单向链表来说，删除一个元素往往检查它前一个元素会更好，引入虚拟头结点也是为了更方便地检查head这个边界特殊点。值得注意的是，C++还有令人头疼的问题，我们需要手动删除目标节点，以免缓存泄漏（当然不删除这道题也会算过）