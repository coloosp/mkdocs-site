# 岛屿数量
好的，从这里开始我们应该是格拉夫（graph）群岛的常驻居民了，我们会详细使用深搜和广搜来解决这块群岛的岛屿数。

## 代码（广搜）
```
# include <iostream>
# include <vector>
# include <queue>
using namespace std;
int dir[4][2]={0,1,1,0,0,-1,-1,0};//方向数组，用来控制节点上下左右移动
void bfs(const vector<vector<int>> graph,vector<vector<int>>& visited,int x,int y){
    queue <pair<int,int>> que;
    que.push({x,y});
    visited[x][y]=true;
    while(!que.empty()){
        pair<int,int> pr=que.front();
        int cur_x=pr.first;
        int cur_y=pr.second;
        que.pop();
        for(int i=0;i<4;i++){
            int next_x=cur_x+dir[i][0];
            int next_y=cur_y+dir[i][1];
            
            if(next_x <0 || next_x>=graph.size() || next_y <0 ||next_y>=graph[0].size()){//超界判断
                continue;
            }
            if(!visited[next_x][next_y] && graph[next_x][next_y]==1){ //如果搜索的是陆地且之前未标记过
                que.push({next_x,next_y});
            visited[next_x][next_y]=true;
            }



        }
    }
}



int main(){
    int n,m;
    cin >>n>>m;
    int result=0;//岛屿数

    vector <vector<int>> graph (n,vector <int>(m));
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin >>graph[i][j];
        }
    }//作图

    vector <vector<int >> visited(n,vector<int>(m,false));
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(!visited[i][j] && graph[i][j]==1){//当发现一块未标记的陆地，把整块岛屿全部搜索
                result++;
                bfs(graph,visited,i,j);
            }
        }
    }
    cout << result <<endl;


 return 0;

}
```

## 解析
广搜的思想更像是[二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)，实际上是爸爸像儿子，在我们二叉树的层序遍历里面我们就完成了这种思想，在二叉树里面，当我们检查到一个节点，我们加入这个节点的左右节点到队尾，实际上在这里，当我们检查到一个节点，我们把这个节点的上下左右加入到队列尾部（前提是未标记且尾超界），在二叉树里面不会出现重复搜寻一个节点并且最终搜索会到nullptr停止，在图论里面我们就需要格外注意这些。

广搜的搜寻方式更像是环形的，扩张的，它具有穷举和无目的性。或许以后我们会有更精明的算法（例如A*算法实际上是以图论为基础），不过建好深搜和广搜两个地基才是解决后面的关键。

