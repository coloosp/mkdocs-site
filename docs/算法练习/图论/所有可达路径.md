# 所有可达路径
[所有可达路径](https://kamacoder.com/problempage.php?pid=1170)
图论，我们从深搜开始，图论是搜索的主旋律，在这里你能学会更多关于搜索的知识，深搜和广搜是我们必要的知识。本题属于深搜题目

## 代码
```
# include <iostream>
# include <list>
# include <vector>
using namespace std;
vector <vector <int>> result;
vector <int> path;
void dfs(const vector<list<int>> &graph,int x,int n){
    if(x==n){//终止条件
        result.push_back(path);
        return ;
    }

    for(int i :graph[x]){//实际上深搜就是回溯，探索完一条路径后，向上返回
        path.push_back(i);
        dfs(graph,i,n);
        path.pop_back();//恢复
    }
}



int main(){
int n,m;
cin >>n >>m;//n是节点数，m是边数
vector <list<int>>  graph (n+1);//建立一个n+1长度的邻接表，因为我们从1开始记录
int s,t;

while(m--){
    cin >>s>>t;
    graph[s].push_back(t);
}
    path.push_back(1);//手动加入1，当我们返回也会退回1这里
    dfs(graph,1,n);
    if(result.size()==0){//判空
        cout <<"-1"<<endl;
    }

    for(const vector<int> p: result){
        for(int i=0;i<p.size()-1;i++){
            cout <<p[i]<<" ";//输出陷阱
        }
        cout <<p[p.size()-1]<<endl;
    }



}
```

## 解析
如果各位学习过回溯，就会发现这段代码相当熟悉，没错，深搜就是回溯，也就是二叉树的前中后序遍历，让我们回忆一下递归的三步：
1. 确认递归函数和输入参数(在图论题目里面我们一般叫dfs，而在普通搜索里面一般叫backtrack，叫什么都行)
2. 确定终止条件（这里输入的参数x是当前搜索到的节点，如果它到达n终点，可以终止）
3. 处理单层函数（这里我们根据存储的临接表来横向遍历x连接的节点）

这里使用广搜能不能实现呢？至少我不会做，因为广搜无法区分搜索的节点是哪一条路径的（应该可以通过一些手法来实现倒是），广搜一般是用于寻找节点的坐标或者能否到达节点