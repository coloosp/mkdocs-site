# 最大子段和（贪心）
[最大字段和](https://www.luogu.com.cn/problem/P1115)
贪心就多贪点...
首先这道题是需要分类讨论的，如果数组里面的数都是负数，大家一样烂，就选一个最大的输出就行
如果存在正数和负数的数组才是我们真正需要考虑的，我还是要说出那句话“好的开始是成功的一半”，实际上如果我们从正数开始计算就会比从负数开始优势大很多，换句话说，如果我们的总和值已经到了负数，为了防止越陷越深，即使调整起点

```
#include <iostream>
# include <vector>
# include <queue>
// #include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;
	vector <int> nums(n);
	int min_num=INT_MIN;
	bool flag = true;
	for (int i = 0; i < n; i++) {
		cin >> nums[i];
		if (nums[i] < 0) {
			min_num = max(nums[i], min_num);
		}
		if (nums[i] >= 0) {
			flag = false;
		}
	}

	if (flag) {
		cout << min_num << endl;
		return 0;
	}
	
	int result = INT_MIN;
	int count = 0;
	for (int i = 0; i < n; i++) {
		count += nums[i];
		if (count > result) {
			result = count;
		}
		if (count <=0) {
			count = 0;
		}
	}

	cout << result ;

	return 0;
}
```