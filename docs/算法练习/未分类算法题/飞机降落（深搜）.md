# 飞机降落（深搜）
[飞机降落](https://www.luogu.com.cn/problem/P9241)
飞机降没降落我不知道，反正我是飞起来了
这道题也是题解大佬的思路，反正我是不可能想到使用深搜来解决的
```
#include <iostream>
# include <vector>
# include <queue>
#include <algorithm>
# include <unordered_map>
# include <unordered_set>
// #include <bits/stdc++.h>
using namespace std;
int t[15], d[15], l[15];
int n;
bool flag = false;
int book[15];

void dfs(int step, int time) {

	if (step == n+1) {
		flag = true;
		return ;
	}

	if (flag) {
		return ;
	}

	for (int i = 1; i <= n; i++) {
		if (book[i]) {
			continue;
		}
		if (t[i] + d[i] < time) {
			return;
		}
		book[i] = 1;
		int s = t[i];
		if (s < time) {
			s = time;
		}

		dfs(step + 1, s + l[i]);
		book[i] = 0;
	}


}



int main() {
	int a;
	cin >> a;
	while (a--) {
		memset(book, 0, sizeof(book));
		cin >> n;
		flag = false;
		for (int i = 1; i <=n; i++) {
			cin >> t[i] >> d[i] >> l[i];
		}

		dfs(1, 0);
		if (flag) {
			cout << "YES" << endl;
		}
		else {
			cout << "NO" << endl;
		}
		}
	return 0;
}
```

step：步数
time：上一架飞机的降落时间
book：标记数组

我需要解释一下为啥上一架飞机要在s+l[i]降落，就是dfs传入的。
根据例子，假如有三飞机准备降落，他们先商量一下谁第一个下（是的，输入顺序不一定是降落顺序，这很明显），假如a飞机要第一个下，那bc飞机就问了“大哥你都第一个下了，你来逗留时间d干嘛，找打吗”
是的，因为我们规定的降落策略是a->b->c，那作为第一个下的飞机a肯定要**尽可能早**降落，这是一点贪心的思想，否则它就不应该是第一个下来。而我们进行判断时，需要看能否在上一架飞机降落时间后进行降落，也就是t[i]+d[i]，这时候是不得已需要逗留

然后就是dfs传入的应该是step+1，我们每成功传入一个，说明一个飞机成功完成降落，如果传入的是i，实际上可能只有第三架飞机降落了而已

好吧，深搜是纯粹且强力的算法，不过这种题是连基础的贪心思想都没有想到，也不可能有后续的深搜了

