# 数列前缀和
[数列前缀和](https://www.luogu.com.cn/problem/B3693)
前缀和的模板题目，但是二维前缀和
看起来唬人，实际上真的能被吓到
![alt text](image-1.png)
“好过分的家伙”

好吧，首先这个对2^64^确实吓人，必须使用unsigned long long，接下来就是优化时间，这里的时间要求极其严格，所以在计算矩阵元素和的时候必须优化到O（n）

```
#include <iostream>
# include <vector>
# include <queue>
#include <algorithm>
# include <unordered_map>
# include <unordered_set>
# include <cmath>
# include <string>
// #include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
int result,T;
int matrix[1005][1005];
int n, m, q;
int u, v, x, y;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> T;
	while (T--) {
		memset(matrix, 0,sizeof(matrix));
		cin >> n >> m >> q;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				int a;
				cin >> a;
				matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1] - matrix[i - 1][j - 1] + a;
			}
		}

		result = 0;
		while (q--) {
			cin >>u >> v >> x >> y;
			int ans = matrix[x][y] + matrix[u-1][v-1]-matrix[u-1][y]-matrix[x][v-1];
			result ^= ans;
		}
		cout << result << endl;




	}




	return 0;
}
```

这个前缀和我们还是举一个简单的例子
比如
1 2 3
4 5 6 
7 8 9
这个矩阵的前缀和应该是
1 3 6
5 12 21
12 27 45

matrix前缀和的[i][j]表示从[1][1]到[i][j]的元素和
这个好理解

那如果我们想要求二行二列到三行三列的元素和？
也就是
5 6
8 9
应该是
45-12-6+1=28
这样就很好理解代码的算式了，现推也行，洛谷倒是也有很多大佬解释原理，我使用例子应该也能很好解释

哦对了，这道题卡输入输出，你能看见我使用了神秘的加速咒语
`	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);`
只能说没办法，遇到了就受着吧