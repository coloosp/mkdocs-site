# 八皇后（回溯）
[八皇后](https://www.luogu.com.cn/problem/P1219)
“愿你在怒中生力”
n皇后问题是我们在回溯路上的最终boss，兼具回溯思想，边界处理，几何思维于一身的究极模板题（不至于）
学会n皇后也意味着回溯的深刻理解了（并没有）

笔者在去年暑假写了一下午才写出来第一次
这次只用了不到一小时 ^ _ ^
```
#include <iostream>
# include <vector>
# include <queue>
#include <algorithm>
# include <unordered_map>
# include <unordered_set>
# include <cmath>
# include <string>
// #include <bits/stdc++.h>
using namespace std;
int n;
vector <vector<int>> result;
vector <int> path;
int ans = 0;
int graph[14][14];

bool isvalid(int row, int col) {
	for (int i = 1; i < row; i++) {
		if (graph[i][col] == 1) {
			return false;
		}
	}//列搜

	for (int i = row - 1, j = col - 1; i >= 1 && j >= 1; i--, j--) {
		if (graph[i][j] == 1) {
			return false;
		}
	}//斜对角左上

	for (int i = row - 1, j = col + 1; i >= 1 && j <= n; i--, j++) {
		if (graph[i][j] == 1) {
			return false;
		}
	}

	return true;

}


void backtrcking(int row) {
	if (row == n+1) {
		result.push_back(path);
		ans++;
		return;
	}

	for (int i = 1; i <= n; i++) {
		if (isvalid(row,i)) {
			graph[row][i] = 1;
			path.push_back(i);
			backtrcking(row + 1);
			path.pop_back();
			graph[row][i] = 0;
		}
	}


}




int main() {
	cin >> n;
	backtrcking(1);
	int t = 0;
	for (vector <int> vc : result) {
		
		for (int i = 0; i < n; i++) {
			cout << vc[i] << " ";
		}
		cout << endl;
		t++;
		if (t >= 3)
			break;
	}
	cout << ans << endl;
}
```

n皇后问题可以拆解为两部分，回溯函数+判断函数

1.回溯的时候为什么是row=n+1
答：因为我们要处理到row=n，下一次进回溯变成n+1需要返回

2.我们的回溯函数是按行来处理，务必记住

3.为什么判断函数没有对行的检测
答：正如前面说的，因为我们是按行处理的，每一行只会有一个棋子

4.为什么判断函数只会处理棋子之上的检测
答：因为我们处理到下该棋子时，后面的“行”还没下，我们只处理到row的位置

5.题目说字典序为什么没有判断
答：因为不需要，我们一定会先判断更前的位置是否能下出来棋子，天然就是字典序来的

n皇后是庞然大物，连名字都这么吓人，不过如果我们认真拆解分析，实际上没有那么难