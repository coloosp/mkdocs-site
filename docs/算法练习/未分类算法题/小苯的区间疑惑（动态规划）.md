# 小苯的区间疑惑（动态规划）

有趣且实用的动态规划，值得记住
我们可以把选择i的区间看成，包含i的左区间最大值+包含i的右区间最大值-nums[i]

## 动态规划（MTE）
```
#include <iostream>
# include <vector>
# include <queue>
# include <unordered_map>
// #include <bits/stdc++.h>
using namespace std;

int main() {
	long long n;
	cin >> n;
	vector <long long> nums(n);
	vector <vector <pair <long long, long long>>>  dp(n,vector<pair<long long,long long>>(n));

	for (long long i = 0; i < n; i++) {
		cin >> nums[i];
	}

	//first 表示选择
	//second表示不选择
	for (long long i = 0; i < n; i++) {//初始化
		dp[i][i].first = nums[i];
		dp[i][i].second = nums[i];
	}


	for (long long i = 0; i < n; i++) {
		for (long long j = i+1; j < n; j++) {
			dp[i][j].first = dp[i][j-1].first + nums[j];
			dp[i][j].second = max(dp[i][j-1].first, dp[i][j-1].second);
		}

		for (long long j = i - 1; j >=0; j--) {
			dp[i][j].first = dp[i ][j+1].first + nums[j];
			dp[i][j].second = max(dp[i ][j+1].first, dp[i ][j+1].second);
		}
	}

	for (long long i = 0; i < n; i++) {
		long long result = max(dp[i][0].first, dp[i][0].second) + max(dp[i][n - 1].first, dp[i][n - 1].second) - nums[i];

		cout << result << " ";
	}








	return 0;
}
```

动态规划的精华在于选与不选，如果我们选，那就都选，不选，就在前面挑一个最大值

不过这样做的后果是空间爆炸，因为我们开了一个O(N²)的空间

## 动态规划（左右区间优化）
```
#include <iostream>
# include <vector>
# include <queue>
# include <unordered_map>
// #include <bits/stdc++.h>
using namespace std;

int main() {
	long long n;
	cin >> n;
	vector <long long> nums(n);
	

	for (long long i = 0; i < n; i++) {
		cin >> nums[i];
	}

	vector <long long> left(n);
	vector <long long> right(n);

	left[0] = nums[0];
	for (long long i = 1; i < n; i++) {
		left[i] = max(left[i - 1] + nums[i], nums[i]);
	}

	right[n - 1] = nums[n - 1];
	for (long long i = n - 2; i >= 0; i--) {
		right[i] = max(right[i + 1] + nums[i], nums[i]);
	}

	for (long long i = 0; i < n; i++) {
		cout << left[i] + right[i] - nums[i] << " ";
	}

	






	return 0;
}
```

实际上我们本可以分离出来，我们单独计算到i左区间和到i右区间的最大和，并且实际上，这里用到了前缀和，如果到i的左前缀和>0,那么left[i]就会加上i，这有的赚，反之，亏本的买卖我不干（突然押韵），右区间亦是如此