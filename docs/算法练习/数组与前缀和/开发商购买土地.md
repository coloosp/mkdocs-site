# 开发商购买土地
[开发商购买土地](https://kamacoder.com/problempage.php?pid=1044)
使用前缀和来解决，要记住，前缀和的本质是预先处理，暴力会把处理后的数据丢弃，在下一次循环中再次处理，避免这种浪费所以出现了前缀和
## 代码
```
#include <climits>
#include <iostream>
#include <vector>
using namespace std;
int main() {
  //使用前缀和来解决
    int m,n;
    cin >>m>>n;
    vector<vector<int>> vec(m,vector<int>(n,0));
    int sum=0;
    int result=INT32_MAX;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            cin >>vec[i][j];
            sum+=vec[i][j];
        }
    }

    vector<int> row_sum(m,0);//行前缀和
    vector<int> col_sum(n,0);//列前缀和

    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            row_sum[i]+=vec[i][j];
        }
    }
    for(int i=1;i<m;i++){
        row_sum[i]+=row_sum[i-1];
    }//前面的循环实际上是处理了每一行的和，但我们需要的是直到某一行为止的和，需要再做处理


    for(int j=0;j<n;j++){
        for(int i=0;i<m;i++){
            col_sum[j]+=vec[i][j];
        }
    }

    for(int j=1;j<n;j++){
        col_sum[j]+=col_sum[j-1];
    }

    int temp_sum=0;
    for(int i=0;i<m;i++){
        temp_sum=sum-row_sum[i];
        result=min(result,abs(sum-2*temp_sum));
        temp_sum=0;
    }

    for(int j=0;j<n;j++){
        temp_sum=sum-col_sum[j];
        result=min(result,abs(sum-2*temp_sum));
        temp_sum=0;
    }//对于行与列的分割探索

    cout <<result <<endl;

}

```
## 解析
因为我们需要对于行与列进行分割，所以预先处理好行与列的前缀和，在逐步探索行的前缀和与列的前缀和。很容易解决，写代码的时候注意一下或者画图想想不算难
