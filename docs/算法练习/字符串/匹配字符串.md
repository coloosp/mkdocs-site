# 匹配字符串
当我们见到匹配时就要想到KMP，但是老样子，我们先求暴力解法
## 代码（暴力）
```
class Solution {
public:
    int strStr(string haystack, string needle) {
        for (int i = 0; i < haystack.size(); i++) {
            if (i +needle.size() >haystack.size() ){//剪枝
                break;
            }
                bool flag = true;
            int index_i = i;
            int index = 0;
            while (index < needle.size()) {
                if (haystack[i++] != needle[index++]) {
                    flag = false;
                    break;
                }
            }

            if (flag) {

                return index_i;//匹配成功
            }
            i = index_i;//匹配失败回退
        }

        return -1;
    }
};
```
## 解析
看似O（1），实则O(n*m),当然也可以用两层for循环解决。实际上就是寻找[i+needle.size()]的范围是否能够匹配
匹配成功则返回，匹配失败需要回退
## 代码（KMP）
```
class Solution {
public:
    void getnext(vector <int>&next,const string s){
        int j=-1;
        next[0]=j;
        for(int i=1;i<s.size();i++){//注意这里从1开始，我们需要计算前后缀相同长度
            while(j >=0 && s[i]!=s[j+1]){
                j=next[j];
            }
            if(s[i]==s[j+1]){
                j++;
            }
            next[i]=j;
        }
    }


    int strStr(string haystack, string needle) {
        if(haystack.size() <needle.size())
            return -1;
        
        vector <int> next (needle.size());
        getnext(next,needle);
        int j=-1;
        for(int i=0;i<haystack.size();i++){//这里则是从0开始，因为是正式开始匹配了
            while(j >=0 && haystack[i]!=needle[j+1]){
                j=next[j];
            }

            if(haystack[i]==needle[j+1]){
                j++;
            }
            if(j==needle.size()-1){
                return i-needle.size()+1;
            }
        }
        return -1;



    }
};
```
## 解析
KMP算法不是一时半会能讲清楚的，我能说明的是，KMP算法能在匹配失败的时候找到需要跳转的位置而不是从零开始。记录你成功匹配过的位置而不是从零开始，或许以后能再见到这种思想。我们这里统一将next位置后调1。