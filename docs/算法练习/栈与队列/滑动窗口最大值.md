# 滑动窗口最大值
[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)
终于到了困难题了，不过不要担心，力扣的困难题都是忽悠人的（并不），拼尽全力战胜它吧！
这里我们需要了解一种新的数据结构“单调队列”，后续我们还会了解到单调栈，我的理解是，对于单调队列和单调栈会储存值，当遇到比队列（栈）大或者小的值就向内部清理，话不多说，让我们看看吧
## 代码（单调队列）
```
class Solution {
private :
 class myQueue{
    public:
    deque <int> que;
    void pop(int value){
        if(!que.empty() && value==que.front()){//当我们检测到相同值就把头部弹出，这里是配合主函数的代码专用的函数
            que.pop_front();
        }
    }

    void push(int value){
        while(!que.empty() && value >que.back()){//如果加入的值大于队尾值就一直向前清理
            que.pop_back();
        }
        que.push_back(value);
    }

    int front(){
        return que.front();//队首永远是最大值
    }
 };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
     myQueue que;
     vector <int> result;
     if(nums.size() <k){
        return result;
     }  
        for(int i=0;i<k;i++){
            que.push(nums[i]);
        }

        int num =que.front();
        result.push_back(num);

        for(int i=k;i<nums.size();i++){
            que.pop(nums[i-k]);//清理滑动窗口最前面的值，保持窗口大小
            que.push(nums[i]);
            result.push_back(que.front());
        }


        return result;
    }
};
```
## 解析
这里我们使用了deque的数据结构，这是双向队列的容器。对于这个单调栈来说，队首永远是最大值，我们通过push函数来保证这一点。并且保证队列不会大于k，我们通过pop来完成这一点。确定当前窗口的最大值，通过front来实现。注意我们的单调队列并不是永远k大小，而是不会超过k大小（这是我们区分优先队列的一种形式，虽然优先队列也可以实现相同的效果，但明显这种方式更有效）
这里力扣的评论区有一种有趣的记法，可以看看
![alt text](image.png)
## 代码（优先队列）
```
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int,int>> que;//这里我们存储<值，下标>的二元组
        vector <int> result;
        for(int i=0;i<k;i++){//预装填
            que.push({nums[i],i});
        }
        result.push_back(que.top().first);
        for(int i=k;i<nums.size();i++){
            que.push({nums[i],i});
            while(!que.empty() && que.top().second <=i-k){//保持优先队列的元素小于k
                que.pop();
            }
            result.push_back(que.top().first);
        }
        return result;





    }
};
```
## 解析
虽然优先队列并不是最优解，不过我们也可以学习一下，具体优先队列的含义和用法建议参考[154.html](https://io.zouht.com/154.html)
优先队列是可以对队列中的值自动排序的数据容器（可以通过自定义比较函数来实现更多排序），大家可能会疑惑，优先队列只能弹出最前面的值，那我怎么能确定这个是不是**滑动窗口的最前面的值**呢？好，那我记录不就是了！实现起来也简单，我们存储的是一个二元组，记录下标和值，当我们检查到，优先队列前端下标距离现在下标大于等于k，弹出即可。
优先队列也是相当重要的数据结构，我们也可以称它为“堆”
