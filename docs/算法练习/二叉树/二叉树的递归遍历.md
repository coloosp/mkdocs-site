# 二叉树的递归遍历

终于到我们大名鼎鼎的二叉树了，所谓二叉树也就是两个树杈的树嘛，刚好作者现在是植树节（也是保护环境了对吧），递归在大学课本里面也算是一个小boss级别的人物了吧（完全不算吧），我们会三次认识他的（二叉树，回溯，DFS）让我们来植树造林吧！
[前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
## 代码（前序遍历）
```
class Solution {
public:
    void preTravelsal(TreeNode* cur,vector <int>& vec){
        if(cur == nullptr){//终止
            return;
        }
        vec.push_back(cur->val);//中
        preTravelsal(cur->left,vec);//左
        preTravelsal(cur->right,vec);//右
    }


    vector<int> preorderTraversal(TreeNode* root) {
        vector <int> result;
        preTravelsal(root,result);
        return result;

    }
};
```
[中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
## 代码（中序遍历）
```
class Solution {
public:
    void travelsal(TreeNode* cur,vector<int>& vec){
        if(cur ==nullptr){//终止
            return ;
        }
        travelsal(cur->left,vec);//左
        vec.push_back(cur->val);//中
        travelsal(cur->right,vec);//右
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector <int> result;
        travelsal(root,result);
        return result;
    }
};
```

## 代码（后序遍历）
```
class Solution {
public:
    void travel(TreeNode *cur,vector <int>& vec){
        if(cur ==nullptr){//终止条件
            return;
        1. }
        travel(cur->left,vec);//左
        travel(cur->right,vec);//右
        vec.push_back(cur->val);//中
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector <int> result;
        travel(root,result);
        return result;
    }
};

```

## 解析
对于前序遍历，遍历的顺序是中左右；中序遍历则是左中右；后序遍历是左右中。三者所谓的“序”是强调中间节点的搜索顺序，可能初学者对于递归会相当头疼，因为递归不是直白且线性的代码，其中会隐含很多要素（特别是传入参数的变化）。
大佬曾经教给我的三要素（三部曲）：
1. 确定传入参数和返回值（还要相当注意取址参数和全局参数）
2. 确定终止条件（一定要先想好避免死循环，不给函数写出口就等着跑一万年）
3. 确定单层递归的逻辑（也就是确定每一次调用函数时的运行逻辑）

在这里特别注意的是，这里的左和右并不是指左右节点，而是左右子树，我们每一次递归调用实际上是对于一个新的树的根节点，它的左子树，它的右子树进行访问搜索