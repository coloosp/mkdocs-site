# 二叉树的迭代遍历（中）
实际上对于迭代遍历来说，前序遍历好写的原因是会先放入根节点到栈中，我们才好根据这个根节点访问其叶子节点，这也是我们后序节点需要翻转的原因（因为正常来写就过于麻烦了）
但是对于中序遍历我们没有办法，只能硬着头皮上了

## 代码
```
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack <TreeNode*> st;
        vector <int> result;
        if(root ==nullptr) return result;
        TreeNode *cur=root;
        while(cur !=nullptr || !st.empty()){
            if(cur !=nullptr){
                st.push(cur);
                cur=cur->left;
            }
            else{ //cur访问到了叶子节点的左节点或者右节点（实际上都为空）
                cur=st.top();
                st.pop();
                result.push_back(cur->val);
                cur=cur->right; //这里有两种可能，一种是cur是当前左右叶子节点，那么接下来它会变为空节点，接下来返回当前（上一层）的中节点；另一只是cur此时是中节点，接下来它会变成右节点
            }
        }

        return result;




    }
};
```
## 解析
大体思路是，我们会先存入全部的左节点，因为我们的访问顺序是左中右，要把左节点当做搜寻的开始。访问左节点直到访问到左叶子节点的左空节点，弹出左节点栈顶为中节点，弹出中节点栈顶为右节点。可能有些不好想，这里的else实际上处理了很多情况，具体画图可能会方便思考