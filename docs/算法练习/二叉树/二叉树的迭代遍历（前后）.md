# 二叉树的迭代遍历
大家可能会见到“迭代”这个词，什么产品迭代，打法迭代，所谓迭代就是通过重复的过程来逐渐逼近并获取最终结果。如果各位了解递归的编程原理（实际上我也不太了解），递归会把需要调用的函数放入一个栈中，然后按照顺序取出并调用它们。
这就好办了，我们可以利用栈来存入节点，让节点代替函数进行处理

## 代码（前序）
```
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack <TreeNode*> st;
        vector <int> result;
        if(root==nullptr) return result;
        
        st.push(root);
        while(!st.empty()){
            TreeNode *cur=st.top();
            result.push_back(st.top()->val);//中
            st.pop();
            if(cur->right) st.push(cur->right);  //右，因为先放入右再放入左，才会先搜寻左
            if(cur->left)  st.push(cur->left);   //左,如果左存在
        }
            return result;
    }
};
```

## 代码（后序）
```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack <TreeNode*> st;
        vector <int> result;
        if(root ==nullptr) return result;
        st.push(root);
        while(!st.empty()){
            TreeNode * cur=st.top();
            result.push_back(st.top()->val);
            st.pop();
            if(cur->left) st.push(cur->left);
            if(cur->right) st.push(cur->right);//为了保持遍历顺序为中右左
        }
        reverse(result.begin(),result.end());//中右左翻转即为左右中
        return  result;




    }
};
```
## 解析
其实我在GPT里面生成了神金小故事，可以看看
   > # 二叉树小镇的宝藏探寻之旅
   > 
   > 在一个遥远而神秘的地方，有一座名叫二叉树的小镇。这个小镇布局十分奇特，它由许多房屋组成，每一栋房屋都有两条道路通向另外两栋房屋，就像一棵大树不断地分叉生长。传说在小镇的某个角落里藏着一份巨大的宝藏，吸引了无数勇敢的探险家前来寻找。
   > 
   > 有一天，一位名叫小栈的年轻探险家听闻了这个传说，他决定踏上在二叉树小镇寻找宝藏的征程。小栈知道，要在这么大的小镇里找到宝藏并不容易，他必须有一个好的探索计划。于是，他想到了一个特殊的工具——一个神奇的背包，这个背包就像一个“栈”，可以按照特定的顺序存放和取出物品。
   > 
   > 小栈来到小镇的入口，这里是小镇的第一栋房屋，也是整个二叉树小镇的“根房屋”。他打开背包，把“根房屋”的地图卡片放了进去。小栈心里清楚，按照他的计划，每次从背包里拿出一张地图卡片，就意味着要去探索对应的房屋。
   > 
   > 小栈从背包里取出“根房屋”的地图卡片，来到了这栋房屋前。他仔细地在房屋里搜索着，不放过任何一个角落，但可惜没有找到宝藏。不过，他发现了两条道路，分别通向“左子房屋”和“右子房屋”。小栈根据自己的计划，先把“右子房屋”的地图卡片放进背包，再把“左子房屋”的地图卡片放进去。这是因为他想先探索左边的房屋，而背包这个“栈”是后进先出的，这样就能保证他先去“左子房屋”。
   > 
   > 接着，小栈从背包里取出“左子房屋”的地图卡片，前往这栋房屋。他在“左子房屋”里又进行了一番仔细的搜索，还是没有发现宝藏的踪迹。但这栋房屋同样有两条道路，通向它自己的“左子房屋”和“右子房屋”。小栈还是按照之前的做法，先把“右子房屋”的地图卡片放进背包，再把“左子房屋”的地图卡片放进去。
   > 
   > 就这样，小栈不断地从背包里取出地图卡片，前往对应的房屋进行搜索，每到一栋房屋，就把它的“右子房屋”和“左子房屋”的地图卡片按照顺序放进背包。他沿着小镇的道路不断深入，时而向左，时而向右，就像在二叉树的枝干间穿梭。
   > 
   > 终于，在经过了一番艰苦的探索后，小栈来到了一栋看似普通的房屋前。他从背包里取出这栋房屋的地图卡片，怀着忐忑的心情走进了房屋。当他在房屋的一个隐蔽角落里打开一个箱子时，一道耀眼的光芒射了出来——他终于找到了传说中的宝藏！
   > 
   > 小栈兴奋不已，他成功地利用背包这个“栈”，按照前序遍历的方式，在二叉树小镇里找到了宝藏。这个特殊的探索方式让他有条不紊地走遍了小镇的每一个角落，最终实现了自己的目标。
   > 
   > 从此以后，小栈成为了二叉树小镇的传奇人物，他的故事也在小镇里流传开来，激励着更多的人去探索未知的世界。而他使用的“栈”和前序遍历的方法，也成为了小镇居民们探索未知区域的经典策略。 
   
说回正题，对于前序遍历，也就压入和取出栈的过程，取出一个节点并存储到result中，再把它的左右压入栈中（务必注意压入的顺序）。那么后序遍历该怎么做呢？答案是翻转了，既然后序遍历是左右中，那么只需要将中右左的顺序翻转即可。我要说的重点不是这个，而是对于cur左右节点为什么需要判断是否为空？而在递归里面不需要呢？实际上我们强调过，递归必须写明终止条件，而如果访问到空节点，就会自动返回，**回退到上一个节点**。对于迭代来说，一个栈不可能存储一个空节点，也允许访问一个空节点的左右指针。到达终止条件就返回上一步，这或许是递归的一个重要特性