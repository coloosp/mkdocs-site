# 对称二叉树
[对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)
实际上不算很简单，而且实际上不能使用层序遍历来实现（层序遍历不能判断每一层元素的位置，当遇到一段是空节点是无法判断位置），做这道题之前我们需要知道如何判断一个对称二叉树：首先，我们判断根的左右节点是否相同，然后我们会判断左节点的左子树和右节点的右子树是否相同，左节点的右子树和右节点的左子树是否相同。
没有了，为什么不说判断根节点的左右子树是否相同呢？因为我们是对称二叉树，你可以试想如何才是对称，**d和d不是对称，d和b才是对称。**

## 代码
```
class Solution {
public:
    bool compare(TreeNode* left,TreeNode* right){
        if(left==nullptr && right==nullptr) return true;//叶子节点
        else if(left !=nullptr && right==nullptr) return false;
        else if(left ==nullptr && right!=nullptr) return false;//先判断有没有

        if(left->val !=right->val) return false;//只有叶子节点或者出现错误才向上返回

        bool outside =compare(left->left,right->right);
        bool insided=compare(left->right,right->left);
        bool is_same=outside && insided;
        return is_same;
    }


    bool isSymmetric(TreeNode* root) {
        if(root==nullptr) return true;
        bool result=  compare(root->left,root->right);
        return result;
    }
};
```

## 解析
实际上这道题我也苦闷了很久，当时第一次做的时候只是照猫画虎完成了一下，对于为什么需要对比左右节点的左右子树并不太理解，各位如果看代码的话，就知道我们分成两块判断，外层判断和内层判断，就像我们说的，我们需要对折一个二叉树，要保证的是“对称性”而不是“相同性”。我们就需要保证每一层的对称性完善，是的，outside和inside就是在保证对称性的完善。

当然我们无敌的层序遍历难道就真的不能用了吗？答案是，我造假不就是了吗！
想想我们之前为什么不能使用层序遍历，假如我们一层是这样的[nullptr,2,nullptr,2]这显然不对称，但层序遍历会略过nullptr节点，变成[2,2]，那就好办了，我把所有空节点作为一个特殊值不就行了，题目的值是[-100,100]我们取个-100吧
## 代码（层序）
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        TreeNode *fakenode=new TreeNode(-101);//假节点
        queue <TreeNode*> que;
        if(root ==nullptr) return true;
        que.push(root);
        while(!que.empty()){
            int size=que.size();
            string str1;
            while(size--){
                TreeNode *cur=que.front();
                que.pop();
                str1.push_back(cur->val);
                if(cur !=fakenode){
                    if(cur->left){
                        que.push(cur->left);
                    }
                    else{

                        que.push(fakenode);
                    }
                    if(cur->right){
                        que.push(cur->right);
                    }
                    else{
                        que.push(fakenode);
                    }

                }
            }
            string str2=str1;
            reverse(str1.begin(),str1.end());
            if(str2 !=str1){
                return false;
            }


        }

        return true;


    }
};
```