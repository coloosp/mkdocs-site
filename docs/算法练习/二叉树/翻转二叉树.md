# 翻转二叉树
[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
翻转了，层序遍历来了杀完了。所以说层序遍历对于很多二叉树问题有种相当出色的效果

## 代码（层序）
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        queue <TreeNode*> que;
        if(root!=nullptr){
            que.push(root);
        }
        while(!que.empty()){
            int size=que.size();
        while(size--){
            TreeNode* node=que.front();
            que.pop();
            swap(node->left,node->right);//交换节点的左右节点
            if(node->left) que.push(node->left);
            if(node->right) que.push(node->right);//只需要将每一层的访问顺序对调即可
        }
        }
        return root;
    }
};
```
## 解析
所谓翻转二叉树，实际上肯定不是直接交换节点，而是对于指针进行处理，各位可以在草稿纸上画画，实际上处理方式就是交换每个节点的左右子节点指针，就能实现翻转

按照这个思路再来实现一下递归吧
## 代码（递归）
```
class Solution {
public:
    void reverse(TreeNode* &cur){
        if(cur==nullptr) return;
        swap(cur->left,cur->right);//中
        reverse(cur->left);//左
        reverse(cur->right);//右
    }

    TreeNode* invertTree(TreeNode* root) {
        reverse(root);
        return root;
    }
};
```

## 解析
牢记我们需要做的，当我们遇到一个节点，就交换它的左右节点，当我们经历的左右节点全部交换之后就满足翻转二叉树了，这里我们使用的是前序遍历的形式，前序遍历也是最好理解的，我们遇到了节点就需要翻转，所以会把单次处理的“中”放在最前面，然后再去找它的左右子树继续处理
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void reverse(TreeNode* &cur){
        if(cur==nullptr) return;
        reverse(cur->left);//左
        reverse(cur->right);//右
        swap(cur->left,cur->right);//中
    }

    TreeNode* invertTree(TreeNode* root) {
        reverse(root);
        return root;
    }
};
```
各位如果仔细想想，后序遍历左右中也是可以的，不过它的实现逻辑是把最小的子树先翻转，再来翻转更大的子树（不过只要所有节点都完成翻转无论翻转顺序如果都是允许的）。但是中序遍历左中右就不太行了，它会把有些节点翻转两次（想想中序遍历也挺头疼的，大家拿纸画画吧）
