# 组合总和
和前面不一样的是，这里我们可以无限制选取一个元素，并且没有长度的要求，所以需要我们使用ans来**记录**当前的和。注意其中细微的变化，回溯很容易在这些地方出错

## 代码
```
class Solution {
public:
    vector <vector<int>> result;
    vector <int> path;
    void backtracking(const vector<int>& candidates,int target,int ans,int index){
        if(ans==target){
            result.push_back(path);
            return;
        }
        else if(ans >target){
               return; 
        }

        for(int i=index;i<candidates.size();i++){
            if(ans+candidates[i]>target){
                continue;
            }
            ans+=candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates,target,ans,i);//因为可以重复选取，所以不需要+1
            ans-=candidates[i];
            path.pop_back();
        }

    }



    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracking(candidates,target,0,0);
        return result;
    }
};
```

## 解析
我认为这里的关键就是，数字可以无限选取，所以如果上一层我们选取了，candidates[index]，下一次选取的范围还是[index,candidates.size()],而如果是不能重复选取，下一次应该是index+1.但虽然是没有选取限制，但是我们仍然选取的是“集合”，没有顺序的因素，所以[1,2]和[2,1]是不能重复出现的，可能会疑惑这一点，那为什么不算是每一次都是从0开始选取呢？实际上这样就会导致[2,对3,3]和[3,2,3]的重复出现，实际上面集合的处理就是，必须在我们path里面按照下标从小到大的填入（是candidates的下标而不是数值）