# 组合
[组合](https://leetcode.cn/problems/combinations/)
回溯是我大学里面最喜欢的算法，它同时具有暴力的特性和搜索的思想，回溯是暴力的代名词，回溯实际上就是暴力地搜索到底，再逐渐向上返回。我们以后还会认识到他的，他的名字又叫深搜。
在本题中，我们也是一样，搜索到k个数字，然后向上恢复

## 代码
```
class Solution {
public:
    vector <vector <int>> result;
    vector<int> path;
    void backtracking(int n,int k,int index){
        if(path.size()==k){//终止条件
            result.push_back(path);
            return;
        }

        for(int i=index;i<=n;i++){
            path.push_back(i);
            backtracking(n,k,i+1);
            path.pop_back();//这里是上一层函数返回后的处理，处理到这里实际上说明已经完成了这条路径的搜索
        }

    }

    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;

    }
};
```

## 解析
回溯对于新手来说是相当困难的，要在大脑中想象是一件几乎不可能是事情，实际上回溯可以当做一个树状的结构（实际上我们对于二叉树的搜索就是回溯的用法）。
![alt text](image.png)
（这里稍微用一下卡尔哥的图片）
实际上对于这段搜索，backtrack的函数调用是纵向的，而for循环是横向的。举一个额例子，我们会先在第一层for循环1,2,3,4里面取1，然后进入下一层for在2,3,4,中取一个数，第一次我们会取2，然后再进入backtrack函数，然后遇到终止条件终止该层的backtrack，回到第二次（是的，第二层的函数还有一段没写完），那就是path.pop_back()，此时path里面为[1],弹出后函数结束，进入第一层函数，执行第一层函数的path.pop_back()，将path清空，然后第一层再选择2,进入下一条分支（这样说不太正确，实际上几条分支算是并行处理的）。

对了，还有一件事要提，题目要求的是集合，也就是[1,2]和[2,1]实际上是一个东西，如何避免重复呢？那就是让这个集合从小到大排序，这也就是为什么要在backtrack里面传入i+1

## 代码（剪枝）
class Solution {
public:
    vector <vector <int>> result;
    vector<int> path;
    void backtracking(int n,int k,int index){
        if(path.size()==k){//终止条件
            result.push_back(path);
            return;
        }

        for(int i=index;i<=n-(k-path.size())+1;i++){
            path.push_back(i);
            backtracking(n,k,i+1);
            path.pop_back();//这里是上一层函数返回后的处理，处理到这里实际上说明已经完成了这条路径的搜索
        }




    }





    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;




    }
};

## 解析
剪枝的思路实际上很简单，
k-path.size():还需要加入的元素数
n-i：还剩下的元素数
因此有这样的公式
n-i>=k-path.size()
i<=n-(k-path.size())+1
为什么会加一呢？这和一月到二月有几个月一样，实际上是两个月，因为这是一个左闭的计算

举个例子，n=4，k=3
那么我们必须从1,2开始选择数，否则搜索到尽头实际上是不够元素的